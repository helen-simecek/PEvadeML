#! /usr/bin/env python3
import json
import requests
import os
import sys
import lief
import lib.interface as interface
from lib.interface import bytez_to_binary
import hashlib

# Path to the module
module_path = os.path.split( os.path.abspath( sys.modules[__name__].__file__ ) )[0]

# Path to the json params config file (must be filled in with classifier access information)
__private_data = json.load( open( os.path.join(module_path,'params.json'), 'r' ) )

# Dictionary to store hashes:classifier scores (cache)
hash_dictionary = {}
count = 0

# Define a custom exception (if the classifier fails)
class ClassificationFailure(Exception):
    pass

# Function to query the classifier to get a score
# Takes in a file path and returns a continuous-value score
def get_score(fileName):
	# Read file into bytes	
	data = open(fileName, 'rb').read()
	
	# Hash the bytes just read in
	hash_value = hashlib.sha224(data).hexdigest()

	# Check if the file has already gotten a score from the classifier
	if hash_value in hash_dictionary:
		print("Using hashed value: ", hash_value)
		return hash_dictionary[hash_value]

	# Query the classifier
	response = requests.post(__private_data['url'],
							 headers={'Content-Type': 'application/octet-stream'}, 
							 verify=True, 
							 data=data, 
							 auth=(__private_data['username'], __private_data['password']) )
	
	# Check that the query worked
	if not response.ok:
		raise( ClassificationFailure("Unable to get label for query") )
	
	# Make sure there's a data field
	json_response = response.json()
	if not 'data' in json_response or not 'score' in json_response['data']:
		raise( ClassificationFailure("Can't find ['data']['score'] in response"))

	# Store the response with the hash
	hash_dictionary[hash_value] = json_response['data']['score']

	# Increment the count because the result was not already cached and the classifier had to be queried
	interface.count = interface.count + 1

	return json_response['data']['score']


# Function to submit a file path (and optionally a threshold value) and recieve either a -1 for malicious or a 1 for benign
# Somewhat unnecessary, but might be nice to have (also, I'm not sure if negative or positive should be malicious/benign?)
def get_binary_label(fileName, threshold = None):
	if not threshold:	
		threshold = __private_data['threshold']

	score = get_score(fileName)
	if score > threshold:
		return -1	# malicious
	else:
		return 1	# benign 

# Function that takes in a file path and returns a string stating whether the sample is classified as malicious or benign
# Redundant, but might be nice to have
def get_label(fileName, threshold = None):
	# If a threshold isn't specified, the function defaults to the one defined in the json file
	if not threshold:	
		threshold = __private_data['threshold']

	score = get_score(fileName)
	if score > threshold:
		return 'malicious'	# malicious
	else:
		return 'benign'		# benign 


